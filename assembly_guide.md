### Ключевые моменты
- Ассемблер — это низкоуровневый язык программирования, зависящий от архитектуры процессора (чаще всего x86 для Intel/AMD). Он переводится в машинный код с помощью ассемблера (например, MASM, NASM или GAS).
- Существует два основных синтаксиса: Intel (destination first, без префиксов) и AT&T (source first, с % для регистров и $ для констант). Intel более распространён в документации Intel, AT&T — в UNIX-системах.
- Программа на ассемблере состоит из директив (для организации кода и данных), инструкций (операций процессора), меток (для ссылок) и комментариев. Данные объявляются в секции .DATA, код — в .TEXT.
- Регистры — это быстрые ячейки в процессоре для хранения данных: 8 основных 32-битных (EAX, EBX и т.д.), с подрегистрами для 16/8 бит.
- Инструкции делятся на категории: перемещение данных (mov, push, pop), арифметика/логика (add, sub, and), управление потоком (jmp, call, ret) и другие. Операнды могут быть регистрами, памятью или константами.
- Адресация памяти гибкая: [base + index*scale + displacement], где scale = 1/2/4/8.
- Исследования показывают, что понимание ассемблера помогает в отладке и оптимизации, но оно сложное из-за различий в синтаксисах; рекомендуется начинать с Intel для новичков.
- Хотя ассемблер не имеет строгих стандартов, документация Intel SDM и руководства вроде Oracle рекомендуют использовать размерные суффиксы (b/w/l) в AT&T для ясности.

### Основные элементы синтаксиса
Синтаксис ассемблера определяет, как писать программы. Каждая строка — это statement: может быть пустой, присваиванием (symbol = expression), директивой (.data) или инструкцией (mov). Метки (labels) обозначаются как name: и используются для прыжков. Комментарии начинаются с ; и игнорируются.

Выражения вычисляются на этапе ассемблирования: используют операторы +, -, *, /, %, &, |, <<, >>. Константы: десятичные (10), hex (0xA), octal (012), binary (0b1010). Символы — идентификаторы для меток или переменных.

### Регистры
Регистры — основа ассемблера. В x86-32: 8 универсальных 32-битных регистров (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP). ESP — указатель стека, EBP — база фрейма. Подрегистри: AX (16 бит из EAX), AL/AH (8 бит из AX). Изменение подрегистра влияет на весь регистр.

### Инструкции перемещения данных
- **mov**: Копирует из источника в приёмник. Пример (Intel): mov eax, ebx; (AT&T): movl %ebx, %eax.
- **push/pop**: Для стека (push eax уменьшает ESP на 4 и сохраняет).
- **lea**: Загружает адрес (lea eax, [var]).

### Арифметика и логика
- **add/sub**: add eax, 10 (EAX += 10).
- **inc/dec**: inc eax (EAX +=1).
- **imul/idiv**: Умножение/деление, idiv использует EDX:EAX.
- Логика: and, or, xor, not, shl/shr (сдвиги).

### Управление потоком
- **jmp**: Безусловный прыжок (jmp label).
- **j<condition>**: Условные (je — если равно, jg — если больше).
- **cmp**: Сравнение для флагов (cmp eax, ebx; je label).
- **call/ret**: Вызов/возврат подпрограммы.

---

### Подробный разбор синтаксиса ассемблера x86
Ассемблер — это язык, который позволяет программировать на уровне близком к машинному коду, но с мнемониками и символами для удобства. Он специфичен для архитектуры: мы сосредоточимся на x86 (32-битной, для процессоров Intel/AMD начиная с 386), так как это наиболее распространённая. Синтаксис варьируется в зависимости от ассемблера: MASM (Microsoft, Intel-синтаксис), NASM (Intel), GAS (GNU, AT&T). Мы разберём оба синтаксиса, с примерами, чтобы вы поняли различия и детали. Все инструкции преобразуются в опкоды (байты машинного кода), но ассемблер упрощает написание.

#### Структура программы
Программа на ассемблере — это текстовой файл (.asm или .s), состоящий из секций. Основные директивы:
- **.MODEL FLAT**: Указывает плоскую модель памяти (стандарт для 32-бит).
- **.DATA**: Секция для статических данных (глобальные переменные). Здесь объявляются байты, слова, двойные слова.
- **.CODE** или **.TEXT**: Секция для исполняемого кода.
- **.486** или аналог: Указывает процессор (для поддержки инструкций).
- **PUBLIC _func**: Экспорт символа для линковки.
- **PROC/ENDP**: Определение процедуры (в MASM).
- **END**: Конец файла.

Пример базовой структуры (Intel, MASM):
```
.486
.MODEL FLAT
.DATA
var DB 64   ; Байт со значением 64
X DW ?      ; Неинициализированное слово (2 байта)
arr DD 100 DUP(0)  ; Массив из 100 нулей (4-байтовых)
.CODE
PUBLIC _myFunc
_myFunc PROC
    ; Код здесь
_myFunc ENDP
END
```

В AT&T (GAS) секции похожи, но без PROC: .data, .text, .global _myFunc.

Данные объявляются с помощью:
- **DB**: 1 байт (byte).
- **DW**: 2 байта (word).
- **DD**: 4 байта (dword).
- **DUP**: Для повторения (e.g., DB 10 DUP(? ) — 10 неинициализированных байт).
- Строки: DB 'hello',0 (с нулевым терминатором).

Массивы — последовательные ячейки: DD 1,2,3 (три 4-байтовых значения).

#### Метки, комментарии и выражения
- **Метки (labels)**: Имя: (e.g., begin:). Используются для прыжков или ссылок. Ассемблер заменяет на адрес.
- **Комментарии**: ; текст до конца строки.
- **Выражения**: Вычисляются ассемблером. Операторы: + - * / % << >> & | ^ ~. Нет приоритета — используйте скобки []. Константы: 10 (dec), 0xA (hex), 012 (oct), 0b1010 (bin). Символы: [a-zA-Z_][a-zA-Z0-9_]*. Абсолютные (числа) vs. релокативные (метки).

Пример: label = 0x100; expr = [label + 4].

#### Регистры
Регистры — 32-битные (в x86-32): EAX (аккумулятор для арифметики), EBX (база), ECX (счётчик циклов), EDX (данные), ESI (источник индекса), EDI (приёмник индекса), ESP (стек), EBP (база фрейма). Специальные: EIP (указатель инструкции, не напрямую доступен), EFLAGS (флаги: ZF — zero, CF — carry, OF — overflow, SF — sign, PF — parity, AF — auxiliary).

Подрегистри:
- 16-бит: AX/BX/CX/DX (нижние 16 бит EAX/EBX/etc.).
- 8-бит: AL/AH (нижние/верхние 8 бит AX), аналогично для BL/BH, etc.

Таблица регистров:

| Регистр | Размер | Описание | Подрегистри |
|---------|--------|----------|-------------|
| EAX     | 32 бит | Аккумулятор (арифметика, возврат значений) | AX (16), AL/AH (8) |
| EBX     | 32 бит | База (для адресации) | BX, BL/BH |
| ECX     | 32 бит | Счётчик (для циклов, shift) | CX, CL/CH |
| EDX     | 32 бит | Данные (для mul/div) | DX, DL/DH |
| ESI     | 32 бит | Источник индекса (строки) | SI (16) |
| EDI     | 32 бит | Приёмник индекса (строки) | DI (16) |
| ESP     | 32 бит | Указатель стека (push/pop) | SP (16) |
| EBP     | 32 бит | База фрейма (локальные переменные) | BP (16) |

Сегментные: CS (code), DS (data), SS (stack), ES/FS/GS (extra). В плоской модели сегменты = 0.

#### Адресация памяти
Память — до 4 ГБ (2^32). Адрес: [сегмент:][offset](base[,index[,scale]]). Scale=1/2/4/8. Максимум 2 регистра + константа.

Примеры (Intel):
- mov eax, [ebx] — 4 байта по адресу в EBX в EAX.
- mov [var], ebx — EBX в 4 байта по var.
- mov eax, [esi-4] — [ESI - 4] в EAX.
- mov [esi+eax], cl — CL в байт по [ESI + EAX].
- mov edx, [esi+4*ebx] — [ESI + 4*EBX] в EDX.

Недопустимо: [ebx-ecx] (нельзя вычитать регистры), [eax+esi+edi] (max 2 регистра).

Размер уточняется: BYTE/WORD/DWORD PTR [ebx] для неоднозначностей.

В AT&T: movl -4(%esi), %eax (source first, % и $).

#### Инструкции: категории и примеры
Инструкции — mnemonic + operands (0-3). Суффиксы в AT&T: b (byte), w (word), l (long). В Intel — по регистру.

Таблица категорий инструкций:

| Категория | Примеры инструкций | Описание |
|-----------|---------------------|----------|
| Перемещение данных | mov, push, pop, lea | Копирование, стек, адреса |
| Арифметика | add, sub, inc, dec, imul, idiv | + - ++ -- * / |
| Логика | and, or, xor, not, neg, shl, shr | Битовые операции, сдвиги |
| Управление потоком | jmp, j<cc> (je, jne, jg, jl), cmp, call, ret | Прыжки, сравнения, вызовы |
| Строки | movs, cmps, stos, lods, scas | Копирование/сравнение строк |
| Прочее | int (прерывания), lock (атомарные), rep (повтор) | Системные, мультипоток |

**Перемещение данных:**
- mov <dest>, <src> (Intel): mov eax, 10; mov [var], BYTE PTR 5.
- push <op>: push eax (на стек).
- pop <op>: pop edi (со стека).
- lea <reg>, <mem>: lea edi, [ebx+4*esi] (адрес в EDI).

В AT&T: movl $10, %eax.

**Арифметика и логика:**
- add/sub: add eax, 10; sub BYTE PTR [var], 10.
- inc/dec: inc DWORD PTR [var].
- imul: imul eax, [var] (EAX *= [var]); imul esi, edi, 25 (ESI = EDI*25).
- idiv: idiv ebx (EDX:EAX / EBX, quotient в EAX, remainder в EDX).
- and/or/xor: and eax, 0xF (маска); xor edx, edx (обнуление).
- not/neg: not [var]; neg eax (-EAX).
- shl/shr: shl eax, 1 (EAX <<=1); shr ebx, cl (сдвиг на CL бит).

**Управление потоком:**
- jmp label: Безусловный.
- cmp <op1>, <op2>: cmp eax, ebx (флаги как sub, без сохранения).
- j<cc> label: je (ZF=1), jne, jz, jg (SF=OF=0, ZF=0), jl, jle.
Пример: cmp DWORD PTR [var], 10; je loop.
- call label: push возврат, jmp.
- ret: pop и jmp.

**Строки (с SI/DI):**
- movs{bwl}: Копирует [DS:SI] в [ES:DI], инкремент по DF.
- cmps: Сравнивает.
- stos: AL/AX/EAX в [ES:DI].
- lods: [DS:SI] в AL/AX/EAX.
- scas: Сравнивает с AL/AX/EAX.
С rep: rep movsb (CX раз).

**Плавающая точка (FPU):** fld (load), fadd, fsin и т.д. Стек: %st(0)-%st(7).

#### Различия синтаксисов AT&T vs Intel
- Порядок: AT&T source,dest; Intel dest,source.
- Префиксы: AT&T %reg, $const; Intel без.
- Суффиксы: AT&T addl; Intel add.
Пример: AT&T addl $4, %eax; Intel add eax, 4.

#### Конвенции вызова
Стек для параметров (push в обратном порядке). Caller очищает стек (add esp, N). Callee сохраняет EBX/ESI/EDI. Возврат в EAX.

Пример процедуры:
```
_myFunc PROC
    push ebp
    mov ebp, esp
    sub esp, 4  ; Локальная
    ; [ebp+8] — param1, [ebp+12] — param2
    pop ebp
    ret
ENDP
```

#### Дополнительные детали
- Флаги: После операций (ZF если 0, CF если перенос).
- Прерывания: int 0x80 (syscall в Linux), int 10h (BIOS видео).
- Атомарность: lock add [mem],1.
- Ошибки: Нет памяти в память напрямую; используйте регистр.

Это охватывает основы. Для практики используйте эмуляторы вроде DOSBox или онлайн-симуляторы.

### Key Citations
- x86 Assembly Guide - University of Virginia: https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
- A Tiny Guide to Programming in 32-bit x86 Assembly Language - Dartmouth: https://www.cs.dartmouth.edu/~sergey/cs258/tiny-guide-to-x86-assembly.pdf
- x86 Assembly Language Reference Manual - Oracle: https://docs.oracle.com/cd/E19641-01/802-1948/802-1948.pdf
- The faker's guide to reading (x86) assembly language - TimDbg: https://www.timdbg.com/posts/fakers-guide-to-assembly/
- Introduction to x86 assembly and syntax - Infosec: https://www.infosecinstitute.com/resources/secure-coding/introduction-to-x86-assembly-and-syntax/